;; (module centring.core) FIXME: implement modules

;;;; Option

(defenum Option
  (Some val)
  (None))

(def Some Option.Some)
(def None Option.None)

;;;; Result

(defenum Result
  (Ok val)
  (Err msg))

(def Ok Result.Ok)
(def Err Result.Err)

;;;; List Basics

(def (first ls :List.Empty) (None))
(def (first (List.Pair v _) :List.Pair) (Some v))

(def (rest ls :List.Empty) ls)
(def (rest (List.Pair _ vs) :List.Pair) vs)

(def (prepend v ls :List) (List.Pair v ls))

;;;; StringSeq

(defrecord (StringSeq str index))

(def (seq s :String) (StringSeq s 0))

(def (first (StringSeq s i) :StringSeq)
  (if (< i (count s))
    (Some (get s i))
    (None)))

(def (rest (StringSeq s i) :StringSeq)
  (StringSeq s (inc i)))

;;;; Function Utils

(def (comp & fs)
  (fn (arg) (foldr (fn (f acc) (f acc)) arg fs)))

(def (constantly v)
  (fn (_) v))

(def (flip f)
  (fn (a b) (f b a)))

;;;; Numeric Utils

(def (inc n) (+ n 1))
(def (dec n) (- n 1))
(def (zero? n) (= n 0))

;;;; Stack Functions

(def (peek ls :List) (first ls))
(def (push ls :List v) (prepend v ls))
(def (pop ls :List) (rest ls))

;;;; Seq Functions

(defrecord (Reduced v))

(def (reduce f acc ls :List.Empty)
  acc)
(def (reduce f acc (List.Pair v vs) :List.Pair)
  (match (f acc v)
    ((Reduced res) res)
    (acc (reduce f acc vs))))

(def (foldr f acc ls :List.Empty)
  acc)
(def (foldr f acc (List.Pair v vs) :List.Pair)
  (f v (foldr f acc vs)))

(def (reverse ls :List)
  (reduce (flip prepend) '() ls))

(def (any? pred? coll)
  (reduce (fn (acc v) (if (pred? v) (Reduced #t) acc)) #f coll))

;;;; Monads

(def (>> mv1 mv2)
  (mbind mv1 (fn (_) mv2)))
